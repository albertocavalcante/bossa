//! Git config generator - generates ~/.gitconfig from bossa configuration

use anyhow::{Context, Result};
use std::collections::HashMap;
use std::path::PathBuf;

use crate::paths;
use crate::schema::GitConfig;

/// Generate git config content from GitConfig
pub fn generate(config: &GitConfig, locations: &crate::schema::LocationsConfig) -> Result<String> {
    let mut output = String::new();

    // Header
    output.push_str("# Generated by bossa - DO NOT EDIT DIRECTLY\n");
    output.push_str("# Source: ~/.config/bossa/config.toml\n");
    output.push_str("# Regenerate: bossa configs apply git\n\n");

    // [user] section
    if config.user.name.is_some() || config.user.email.is_some() || config.user.signingkey.is_some()
    {
        output.push_str("[user]\n");
        if let Some(ref name) = config.user.name {
            output.push_str(&format!("    name = {name}\n"));
        }
        if let Some(ref email) = config.user.email {
            output.push_str(&format!("    email = {email}\n"));
        }
        if let Some(ref key) = config.user.signingkey {
            output.push_str(&format!("    signingkey = {key}\n"));
        }
        output.push('\n');
    }

    // Standard sections
    write_section(&mut output, "core", &config.core, locations)?;
    write_section(&mut output, "init", &config.init, locations)?;
    write_section(&mut output, "pull", &config.pull, locations)?;
    write_section(&mut output, "push", &config.push, locations)?;
    write_section(&mut output, "merge", &config.merge, locations)?;
    write_section(&mut output, "diff", &config.diff, locations)?;

    // [alias] section
    if !config.alias.is_empty() {
        output.push_str("[alias]\n");
        let mut aliases: Vec<_> = config.alias.iter().collect();
        aliases.sort_by_key(|(k, _)| *k);
        for (name, command) in aliases {
            output.push_str(&format!("    {name} = {command}\n"));
        }
        output.push('\n');
    }

    // Extra sections
    let mut extra: Vec<_> = config.extra.iter().collect();
    extra.sort_by_key(|(k, _)| *k);
    for (section, values) in extra {
        // Skip known sections that are handled above
        if matches!(
            section.as_str(),
            "user" | "core" | "init" | "pull" | "push" | "merge" | "diff" | "alias" | "target"
        ) {
            continue;
        }
        write_section(&mut output, section, values, locations)?;
    }

    Ok(output)
}

fn write_section(
    output: &mut String,
    name: &str,
    values: &HashMap<String, toml::Value>,
    locations: &crate::schema::LocationsConfig,
) -> Result<()> {
    if values.is_empty() {
        return Ok(());
    }

    output.push_str(&format!("[{name}]\n"));

    let mut items: Vec<_> = values.iter().collect();
    items.sort_by_key(|(k, _)| *k);

    for (key, value) in items {
        let formatted = format_value(value, locations);
        output.push_str(&format!("    {key} = {formatted}\n"));
    }
    output.push('\n');

    Ok(())
}

fn format_value(value: &toml::Value, locations: &crate::schema::LocationsConfig) -> String {
    match value {
        toml::Value::String(s) => {
            // Resolve location references and expand paths
            let resolved = paths::resolve(s, locations);
            resolved.to_string_lossy().to_string()
        }
        toml::Value::Boolean(b) => b.to_string(),
        toml::Value::Integer(i) => i.to_string(),
        toml::Value::Float(f) => f.to_string(),
        toml::Value::Array(arr) => {
            // Git config doesn't really support arrays, join with space
            arr.iter()
                .map(|v| format_value(v, locations))
                .collect::<Vec<_>>()
                .join(" ")
        }
        _ => value.to_string(),
    }
}

/// Get the target path for the git config file
pub fn target_path(config: &GitConfig, locations: &crate::schema::LocationsConfig) -> PathBuf {
    paths::resolve(&config.target, locations)
}

/// Compare generated config with existing file
pub fn diff(
    config: &GitConfig,
    locations: &crate::schema::LocationsConfig,
) -> Result<Option<String>> {
    let target = target_path(config, locations);
    let generated = generate(config, locations)?;

    if !target.exists() {
        return Ok(Some(format!(
            "File does not exist: {}\n\nWould create:\n{}",
            target.display(),
            generated
        )));
    }

    let existing = std::fs::read_to_string(&target)
        .with_context(|| format!("Failed to read {}", target.display()))?;

    if existing == generated {
        return Ok(None);
    }

    // Simple diff output
    Ok(Some(format!(
        "--- {}\n+++ generated\n\nExisting:\n{}\n\nGenerated:\n{}",
        target.display(),
        existing,
        generated
    )))
}
