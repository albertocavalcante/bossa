# Declarative Config Generation & Starlark Configuration

> **Status**: Planning
> **Created**: 2026-02-05
> **Author**: Claude Code Analysis

---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Feature 1: Declarative Config Generation](#feature-1-declarative-config-generation)
3. [Feature 2: Starlark as Config Language](#feature-2-starlark-as-config-language)
4. [Synergy: Starlark + Config Generation](#synergy-starlark--config-generation)
5. [Implementation Plan](#implementation-plan)
6. [Migration Strategy](#migration-strategy)

---

## Problem Statement

### Immediate Problem: Broken Dotfiles

When moving development directories, symlinked dotfiles break:

```
Before: ~/.gitconfig → ~/dev/dotfiles/git/.gitconfig ✓
After:  ~/.gitconfig → ~/dev/dotfiles/git/.gitconfig ✗ (dangling)
```

Result: Git falls back to auto-detection, using wrong identity:

```
Committer: Alberto Cavalcante <adsc@Albertos-Mac-mini.local>  # Wrong!
Expected:  Alberto Cavalcante <54247214+albertocavalcante@users.noreply.github.com>
```

### Deeper Problem: Symlinks Are Fragile

| Issue               | Impact                                   |
| ------------------- | ---------------------------------------- |
| **Path dependency** | Symlinks encode absolute paths           |
| **All-or-nothing**  | Can't override single values per-machine |
| **No composition**  | Can't merge work + personal configs      |
| **No templating**   | Can't use variables or conditionals      |
| **No validation**   | Invalid configs aren't caught early      |

### Even Deeper: TOML Has Limits

TOML is great for simple configs but struggles with:

```toml
# Can't do this in TOML:

# 1. Conditionals
[git]
user.email = if is_work_machine then "alberto@work.com" else "alberto@personal.com"

# 2. Loops/generation
[aliases]
# Generate aliases for all projects...

# 3. Imports
load("//profiles/work.toml")  # Not possible

# 4. Functions
def git_config(name, email):
    return { "user.name": name, "user.email": email }
```

---

## Feature 1: Declarative Config Generation

### Concept

Instead of symlinking static files, **declare desired configuration** and let bossa generate the actual config files:

```toml
# ~/.config/bossa/config.toml

[configs.git]
enabled = true
target = "~/.gitconfig"

[configs.git.user]
name = "Alberto Cavalcante"
email = "54247214+albertocavalcante@users.noreply.github.com"
signingkey = "ABC123"

[configs.git.core]
editor = "nvim"
autocrlf = "input"
excludesFile = "${locations.dotfiles}/git/.gitignore_global"
pager = "delta"

[configs.git.init]
defaultBranch = "main"

[configs.git.pull]
rebase = true

[configs.git.push]
autoSetupRemote = true
default = "current"

[configs.git.merge]
conflictStyle = "diff3"

[configs.git.diff]
colorMoved = "default"

[configs.git.alias]
co = "checkout"
br = "branch"
st = "status"
lg = "log --oneline --graph --decorate"
amend = "commit --amend --no-edit"
unstage = "reset HEAD --"
last = "log -1 HEAD"
```

### Generated Output

Bossa generates `~/.gitconfig`:

```ini
# Generated by bossa - DO NOT EDIT
# Source: ~/.config/bossa/config.toml
# Run 'bossa configs apply' to regenerate

[user]
    name = Alberto Cavalcante
    email = 54247214+albertocavalcante@users.noreply.github.com
    signingkey = ABC123

[core]
    editor = nvim
    autocrlf = input
    excludesFile = /Volumes/T9/dev/dotfiles/git/.gitignore_global
    pager = delta

[init]
    defaultBranch = main

[pull]
    rebase = true

[push]
    autoSetupRemote = true
    default = current

[merge]
    conflictStyle = diff3

[diff]
    colorMoved = default

[alias]
    co = checkout
    br = branch
    st = status
    lg = log --oneline --graph --decorate
    amend = commit --amend --no-edit
    unstage = reset HEAD --
    last = log -1 HEAD
```

### CLI Interface

```bash
# Apply all declared configs
bossa configs apply

# Apply specific config
bossa configs apply git

# Preview changes (dry-run)
bossa configs diff
bossa configs diff git

# Show current status
bossa configs status

# Validate configs without applying
bossa configs check

# Show what would be generated
bossa configs show git
```

### Supported Config Formats

| Tool          | Config File                          | Format     |
| ------------- | ------------------------------------ | ---------- |
| **git**       | `~/.gitconfig`                       | INI        |
| **npm**       | `~/.npmrc`                           | INI-like   |
| **cargo**     | `~/.cargo/config.toml`               | TOML       |
| **pip**       | `~/.pip/pip.conf`                    | INI        |
| **gradle**    | `~/.gradle/gradle.properties`        | Properties |
| **ssh**       | `~/.ssh/config`                      | SSH config |
| **starship**  | `~/.config/starship.toml`            | TOML       |
| **alacritty** | `~/.config/alacritty/alacritty.toml` | TOML       |

### Machine-Specific Overrides

```toml
# Base config
[configs.git.user]
name = "Alberto Cavalcante"

# Machine-specific override file: ~/.config/bossa/local.toml
[configs.git.user]
email = "alberto@work-corp.com" # Override for work machine
```

Or use hostname detection:

```toml
[configs.git.user]
name = "Alberto Cavalcante"
email.default = "personal@email.com"
email.work-laptop = "work@corp.com"
email.work-desktop = "work@corp.com"
```

---

## Feature 2: Starlark as Config Language

### Why Starlark?

Starlark is a deterministic, hermetic dialect of Python designed for configuration:

| Feature           | TOML              | Starlark                      |
| ----------------- | ----------------- | ----------------------------- |
| **Readability**   | ✓ Excellent       | ✓ Good (Python-like)          |
| **Variables**     | ✗ No              | ✓ Yes                         |
| **Functions**     | ✗ No              | ✓ Yes                         |
| **Conditionals**  | ✗ No              | ✓ Yes                         |
| **Loops**         | ✗ No              | ✓ Yes                         |
| **Imports**       | ✗ No              | ✓ `load()`                    |
| **Type Safety**   | ~ Weak            | ✓ Runtime checked             |
| **Deterministic** | ✓ Yes             | ✓ Yes (no I/O, no randomness) |
| **Familiar**      | ~ Config-specific | ✓ Python syntax               |
| **Tooling**       | ✓ Good            | ~ Growing                     |

### Starlark Example

```python
# ~/.config/bossa/config.star

# Load shared definitions
load("//lib/profiles.star", "work_profile", "personal_profile")
load("//lib/git.star", "git_aliases", "git_config")

# Detect environment
IS_WORK = hostname().endswith(".corp.com") or env("WORK_MACHINE") == "1"

# Choose profile
profile = work_profile if IS_WORK else personal_profile

# Git configuration
git = git_config(
    user = profile.git_user,
    signing = profile.signing_key,
    core = {
        "editor": "nvim",
        "pager": "delta",
        "excludesFile": locations.dotfiles + "/git/.gitignore_global",
    },
    aliases = git_aliases() | {
        # Project-specific aliases
        "deploy": "!./scripts/deploy.sh",
    },
)

# Locations (replaces [locations] section)
locations = struct(
    dev = "/Volumes/T9/dev",
    workspaces = locations.dev + "/ws",
    refs = locations.dev + "/refs",
    dotfiles = locations.dev + "/dotfiles",
)

# Collections
collections = {
    "refs": collection(
        path = locations.refs,
        repos = [
            "https://github.com/bazelbuild/bazel",
            "https://github.com/aspect-build/aspect-cli",
            # ... can use loops here!
        ] + [
            "https://github.com/rust-lang/" + repo
            for repo in ["rust", "cargo", "rustfmt"]
        ],
    ),
}

# Conditional features
if IS_WORK:
    collections["work-repos"] = collection(
        path = locations.dev + "/work",
        repos = load("//work/repos.star", "REPOS"),
    )

# Export configuration
config = struct(
    locations = locations,
    collections = collections,
    git = git,
    configs = {
        "git": git.to_gitconfig(),
    },
)
```

### Library Files

```python
# ~/.config/bossa/lib/profiles.star

def _git_user(name, email, signing_key = None):
    return struct(
        name = name,
        email = email,
        signing_key = signing_key,
    )

work_profile = struct(
    git_user = _git_user(
        name = "Alberto Cavalcante",
        email = "alberto@corp.com",
        signing_key = "WORK_KEY_123",
    ),
    signing_key = "WORK_KEY_123",
)

personal_profile = struct(
    git_user = _git_user(
        name = "Alberto Cavalcante",
        email = "54247214+albertocavalcante@users.noreply.github.com",
        signing_key = "PERSONAL_KEY_456",
    ),
    signing_key = "PERSONAL_KEY_456",
)
```

```python
# ~/.config/bossa/lib/git.star

def git_aliases():
    """Standard git aliases."""
    return {
        "co": "checkout",
        "br": "branch",
        "st": "status",
        "lg": "log --oneline --graph --decorate",
        "amend": "commit --amend --no-edit",
        "unstage": "reset HEAD --",
        "last": "log -1 HEAD",
        "wip": "commit -am 'WIP'",
        "undo": "reset --soft HEAD~1",
    }

def git_config(user, signing = None, core = {}, aliases = {}):
    """Create a git configuration."""
    return struct(
        user = user,
        signing = signing,
        core = core,
        aliases = aliases,

        def to_gitconfig(self):
            """Generate .gitconfig content."""
            # ... implementation
    )
```

### Built-in Functions

Bossa would provide these functions to Starlark:

```python
# Environment
hostname()              # → "Albertos-Mac-mini.local"
env("VAR")             # → environment variable or None
env("VAR", "default")  # → with default
platform()             # → "macos" | "linux" | "windows"
arch()                 # → "aarch64" | "x86_64"

# Paths
home()                 # → "/Users/adsc"
config_dir()          # → "~/.config/bossa"
expand(path)          # → expand ~ and $VAR

# Utilities
read_file(path)       # → file contents (restricted to config dir)
glob(pattern)         # → list of matching files
exists(path)          # → bool

# Structs (like Bazel)
struct(...)           # → immutable named tuple
```

### Using starlark-rust

The [`starlark`](https://github.com/facebookexperimental/starlark-rust) crate provides:

```rust
use starlark::environment::{GlobalsBuilder, Module};
use starlark::eval::Evaluator;
use starlark::syntax::{AstModule, Dialect};
use starlark::values::Value;

fn evaluate_config(path: &Path) -> Result<BossaConfig> {
    // Parse
    let ast = AstModule::parse_file(path, &Dialect::Standard)?;

    // Create environment with built-ins
    let globals = GlobalsBuilder::extended()
        .with(bossa_builtins)  // hostname(), env(), etc.
        .build();

    // Evaluate
    let module = Module::new();
    let mut eval = Evaluator::new(&module);
    let result = eval.eval_module(ast, &globals)?;

    // Extract config
    extract_config(result)
}

#[starlark_module]
fn bossa_builtins(builder: &mut GlobalsBuilder) {
    fn hostname() -> String {
        gethostname::gethostname().to_string_lossy().into()
    }

    fn env(key: &str, default: Option<&str>) -> Option<String> {
        std::env::var(key).ok().or(default.map(String::from))
    }

    fn platform() -> &'static str {
        if cfg!(target_os = "macos") { "macos" }
        else if cfg!(target_os = "linux") { "linux" }
        else if cfg!(target_os = "windows") { "windows" }
        else { "unknown" }
    }
}
```

### CLI with Starlark

```bash
# Evaluate and show resolved config
bossa config show

# Validate Starlark syntax
bossa config check

# Evaluate with debug output
bossa config eval --debug

# Show what files would be generated
bossa config diff

# Apply configuration
bossa config apply
```

---

## Synergy: Starlark + Config Generation

### The Full Picture

```
┌─────────────────────────────────────────────────────────────────┐
│                    config.star (Starlark)                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐  │
│  │  Locations  │  │   Profiles  │  │   Config Definitions    │  │
│  │  dev = ...  │  │  work/pers  │  │  git, npm, cargo, ssh   │  │
│  └──────┬──────┘  └──────┬──────┘  └────────────┬────────────┘  │
│         │                │                      │                │
└─────────┼────────────────┼──────────────────────┼────────────────┘
          │                │                      │
          ▼                ▼                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Starlark Evaluation                           │
│  - Resolve conditionals (IS_WORK)                                │
│  - Expand variables (locations.dev)                              │
│  - Execute functions (git_config(...))                           │
│  - Merge imports (load("..."))                                   │
└─────────────────────────────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Resolved Config (struct)                      │
│  {                                                               │
│    locations: { dev: "/Volumes/T9/dev", ... },                  │
│    collections: { refs: { path: "...", repos: [...] } },        │
│    configs: {                                                    │
│      git: { user: {...}, core: {...}, aliases: {...} },         │
│      npm: { ... },                                               │
│    }                                                             │
│  }                                                               │
└─────────────────────────────────────────────────────────────────┘
          │
          ├──────────────────────┬──────────────────────┐
          ▼                      ▼                      ▼
┌─────────────────┐  ┌─────────────────────┐  ┌─────────────────┐
│  ~/.gitconfig   │  │  ~/.cargo/config    │  │  ~/.ssh/config  │
│  (INI format)   │  │  (TOML format)      │  │  (SSH format)   │
└─────────────────┘  └─────────────────────┘  └─────────────────┘
```

### Example: Complete Workflow

```python
# config.star - Single source of truth

load("//lib/machine.star", "detect_profile")
load("//lib/git.star", "standard_git_config")
load("//lib/dev.star", "standard_collections")

# Auto-detect based on machine
profile = detect_profile()

# Locations
locations = struct(
    dev = "/Volumes/T9/dev" if platform() == "macos" else "~/dev",
    dotfiles = locations.dev + "/dotfiles",
)

# All my git settings
git = standard_git_config(
    profile = profile,
    dotfiles = locations.dotfiles,
    extra_aliases = {
        "deploy": "!./deploy.sh",
    },
)

# Collections with computed repos
collections = standard_collections(locations) | {
    # Add personal projects
    "personal": collection(
        path = locations.dev + "/personal",
        repos = [
            "git@github.com:albertocavalcante/" + r
            for r in ["dotfiles", "scripts", "notes"]
        ],
    ),
}

# Symlinks (stow-like)
symlinks = {
    "nvim": {
        "source": locations.dotfiles + "/nvim",
        "target": "~/.config/nvim",
    },
    "zsh": {
        "source": locations.dotfiles + "/zsh",
        "target": "~",
        "files": [".zshrc", ".zprofile"],
    },
}

# Generated configs
configs = {
    "git": git.to_gitconfig(),
    "starship": read_file(locations.dotfiles + "/starship/starship.toml"),
}

# Export
config = struct(
    locations = locations,
    collections = collections,
    symlinks = symlinks,
    configs = configs,
)
```

---

## Implementation Plan

### Phase 1: Config Generation (TOML-based)

Start with TOML, add generation capability:

| Task                          | Effort | Files               |
| ----------------------------- | ------ | ------------------- |
| Config schema for git         | Small  | schema.rs           |
| Git config generator          | Medium | generators/git.rs   |
| `bossa configs` command       | Small  | commands/configs.rs |
| Apply/diff/status subcommands | Medium | commands/configs.rs |

### Phase 2: More Generators

| Task                   | Effort | Files                  |
| ---------------------- | ------ | ---------------------- |
| SSH config generator   | Medium | generators/ssh.rs      |
| Cargo config generator | Small  | generators/cargo.rs    |
| NPM config generator   | Small  | generators/npm.rs      |
| Starship passthrough   | Small  | generators/starship.rs |

### Phase 3: Starlark Foundation

| Task                         | Effort | Files                |
| ---------------------------- | ------ | -------------------- |
| Add starlark-rust dependency | Small  | Cargo.toml           |
| Basic evaluation             | Medium | starlark/mod.rs      |
| Built-in functions           | Medium | starlark/builtins.rs |
| Config extraction            | Medium | starlark/extract.rs  |

### Phase 4: Starlark Migration

| Task                           | Effort | Files            |
| ------------------------------ | ------ | ---------------- |
| Parallel TOML/Starlark support | Medium | config.rs        |
| Migration guide                | Small  | docs/            |
| TOML → Starlark converter      | Large  | tools/convert.rs |

### Phase 5: Advanced Starlark

| Task                  | Effort | Files              |
| --------------------- | ------ | ------------------ |
| Library system (load) | Medium | starlark/loader.rs |
| Standard library      | Large  | lib/*.star         |
| IDE support (LSP)     | Large  | Future             |

---

## Migration Strategy

### Approach: Incremental, Not Big-Bang

1. **Keep TOML working** - Never break existing configs
2. **Add Starlark as option** - `config.star` alongside `config.toml`
3. **Starlark takes precedence** - If both exist, use .star
4. **Provide converter** - `bossa config convert --to-starlark`

### Detection Logic

```rust
fn load_config() -> Result<BossaConfig> {
    let config_dir = paths::config_dir()?;

    // Prefer Starlark if available
    let star_path = config_dir.join("config.star");
    if star_path.exists() {
        return load_starlark_config(&star_path);
    }

    // Fall back to TOML
    let toml_path = config_dir.join("config.toml");
    if toml_path.exists() {
        return load_toml_config(&toml_path);
    }

    // Default empty config
    Ok(BossaConfig::default())
}
```

### Converter Tool

```bash
# Convert TOML to Starlark
bossa config convert --to-starlark

# Preview without writing
bossa config convert --to-starlark --dry-run

# Output:
# Generated ~/.config/bossa/config.star from config.toml
#
# The following manual adjustments are recommended:
# - Line 15: Consider using a profile for git.user
# - Line 32: Path could use locations.dev variable
```

---

## Appendix A: starlark-rust Crate

### Cargo.toml Addition

```toml
[dependencies]
starlark = "0.12" # Check latest version
```

### Key Types

```rust
use starlark::environment::{Globals, GlobalsBuilder, Module};
use starlark::eval::Evaluator;
use starlark::syntax::{AstModule, Dialect};
use starlark::values::{dict::Dict, list::List, structs::Struct, Value};
use starlark::starlark_module;
```

### Documentation

- Crate: https://crates.io/crates/starlark
- GitHub: https://github.com/facebookexperimental/starlark-rust
- Starlark Spec: https://github.com/bazelbuild/starlark/blob/master/spec.md

---

## Appendix B: Comparison with Alternatives

| Tool                 | Config Language | Generation | Pros                        | Cons                    |
| -------------------- | --------------- | ---------- | --------------------------- | ----------------------- |
| **Nix/home-manager** | Nix             | Full       | Very powerful               | Steep learning curve    |
| **chezmoi**          | Go templates    | Templates  | Popular, mature             | Template syntax awkward |
| **Ansible**          | YAML + Jinja2   | Templates  | Widely known                | Heavy for personal use  |
| **Dhall**            | Dhall           | Types      | Type-safe                   | Unfamiliar syntax       |
| **Bossa + Starlark** | Starlark        | Native     | Python-like, Bazel familiar | New approach            |

---

## Appendix C: Git Config Generation Details

### Input Schema

```toml
[configs.git]
# Target file (default: ~/.gitconfig)
target = "~/.gitconfig"

# User identity
[configs.git.user]
name = "Name"
email = "email@example.com"
signingkey = "KEY123" # optional

# Core settings
[configs.git.core]
editor = "nvim"
pager = "delta"
autocrlf = "input"
excludesFile = "~/.gitignore_global"
# ... any git core.* setting

# Any section works
[configs.git.init]
defaultBranch = "main"

[configs.git.pull]
rebase = true

[configs.git.push]
autoSetupRemote = true
default = "current"

# Aliases
[configs.git.alias]
co = "checkout"
st = "status"
```

### Generator Implementation

```rust
// src/generators/git.rs

use std::collections::BTreeMap;

pub struct GitConfig {
    pub sections: BTreeMap<String, BTreeMap<String, String>>,
}

impl GitConfig {
    pub fn from_toml(table: &toml::Table) -> Result<Self> {
        let mut sections = BTreeMap::new();

        for (section, values) in table {
            if section == "target" {
                continue; // Meta-field, not a git section
            }

            let section_map = match values {
                toml::Value::Table(t) => {
                    t.iter()
                        .map(|(k, v)| (k.clone(), value_to_string(v)))
                        .collect()
                }
                _ => bail!("Expected table for section {}", section),
            };

            sections.insert(section.clone(), section_map);
        }

        Ok(Self { sections })
    }

    pub fn to_ini(&self) -> String {
        let mut output = String::new();
        output.push_str("# Generated by bossa - DO NOT EDIT\n");
        output.push_str("# Source: ~/.config/bossa/config.toml\n");
        output.push_str("# Regenerate: bossa configs apply git\n\n");

        for (section, values) in &self.sections {
            output.push_str(&format!("[{}]\n", section));
            for (key, value) in values {
                output.push_str(&format!("    {} = {}\n", key, value));
            }
            output.push('\n');
        }

        output
    }
}
```

---

## Next Steps

1. **Immediate**: Create a simple ~/.gitconfig manually or via bossa
2. **Phase 1**: Implement git config generation in TOML
3. **Phase 2**: Add more generators
4. **Phase 3**: Evaluate starlark-rust integration
5. **Phase 4**: Full Starlark support

The Starlark approach is ambitious but aligns well with bossa's target audience (Bazel users). Starting with TOML-based generation provides immediate value while the Starlark foundation is built.
